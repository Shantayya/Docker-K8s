K8s is powerful tool however few challenges hampers its adoption
1. Deployment complexity: 
order of resource deployment (pod,ns,cm etc). due to dependency order deployment will fail
2. Applicatio versioning and rollback :
rollback is difficult due to K8s not provide built-in mechanism for apps versioning
3. reusability and sharability:
Reusing configurations across different environments is difficult due to different config need tweak according to env. 

Helm: 
Its a tool which manages the K8s based applications by providing standard approach as helm charts(tar -> collection of YAML files). its package manager for k8s.
Helm can:
1. install software
2. auto install software dependancies
3. Upgrade software
4. configure software deployments
5. fetch soft pkgs from soft repo called chart repo (chart museum)

		package manager		packages
system		apt			deb
		yum			rpm
Development	maven			jar/jav artifacts
		npm			node modules
		pip			python packages
K8s		helm			charts

example: 
system				K8s
apt install nginx		helm install <release-name> bitnam/nginx
apt uprade			helm upgrade <release-name> bitnam/nginx

why helm is popular:
1. Hiding complexity of running multiple YAML files to deploy apps. run single command that install all YAML files at once. 
2. one click install/upgrade/rollback apps
3. same charts reusable for multi env. 


why helm is not:
1. its not system package manager.
2. configuration management tool (ansible,shef,puppet etc)
3. K8s resource lifecycle controller 
4. version control system 


----Helm terminologies-------
Helm Client/Helm:
command line tool for developing charts,managing repo,releases and interfacing with helm library

Tiller:
Its a helm server. Interacts directly with K8s API server to install,upgrade,query and remove K8s resources. its installed in K8s cluster and runs as pod. 
Tiller is removed in Helm3.

chart:
A package of pre-configured K8s resources. its tar with collection of YAML files. 

Release:
Its an instance of chart running in K8s cluster. same chart can be deployed multiple times in multiple env. 

Repo:
place where charts resides and can be shared with others. 


---changes from Helm2 to Helm3------ 
1. Tiller removed in helm3   --> When Helm2 was developed K8s did not had RBAC sp helm had to take care of auth part (who and what actions a user can perform in K8s cluster). with K8s 1.6 RBAC is enabled by default so there is no need for helm  to do the same job which can be done by  K8s. 

2. Three way strategic merge patch --> In Helm2 patch would be generated by comparing old manifest with new one. if someone manually changed deployment,helm has no 
info regarding that and rollback would give erroneous result. 
in Helm3 patch is generated using old manifest,live state of cluster and new manifest.

3. secret as default storage driver ---> Helm2 uses ConfigMap to store release info. in Helm3 Secrets are used as default storage driver. 

4. JSON schema chart validation
5. Release name is now required  --> In Helm2 if no name was provided then release name would be generated. Helm3 will throw error if no name is provided. 


